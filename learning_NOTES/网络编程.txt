==========================基本概念================================================

每当客户端成功连接到服务器时，server会把该socket放到一个请求队列中，

ServerSocket(port,backlog,address);改构造方法中backlog是指定该请求队列的长度，一般默认为50，如果超过长度了，server会拒绝

连接，此时客户端socket会抛出ConnectionException只有当server执行accept()方法后，从队列中取出一个请求加以处理后，

才会接收新的客户端请求.对于客户端来说，当它的连接请求被加入到请求队列中的时候，就表示客户端和服务器连接成功。

值得注意的是，如果操作系统的限定队列长度为50，那么如果将backlog设置大于50，或者<= 0那么，此时会采用系统限定的长度50.

ServerSocket 有以下3 个选项。
l SO_TIMEOUT：表示等待客户连接的超时时间。
l SO_REUSEADDR：表示是否允许重用服务器所绑定的地址。
l SO_RCVBUF：表示接收数据的缓冲区的大小。

设置socket的选项，只有在绑定socket前才有效，这时候就需要用到无参的构造方法
ServerSocket server = new ServerSocket();
server.setSoTimeout(5000)	//设置连接时间不能超过5s	


l 设置该选项：public void setReceiveBufferSize(int size) throws SocketException
l 读取该选项：public int getReceiveBufferSize() throws SocketException
SO_RCVBUF 表示服务器端的用于接收数据的缓冲区的大小，以字节为单位。一般
说来，传输大的连续的数据块（基于HTTP 或FTP 协议的数据传输）可以使用较
大的缓冲区，这可以减少传输数据的次数，从而提高传输数据的效率。而对于交
互式的通信（Telnet 和网络游戏），则应该采用小的缓冲区，确保能及时把小
批量的数据发送给对方。
SO_RCVBUF 的默认值与操作系统有关。例如，在Windows 2000 中运行以下代码时，显示
SO_RCVBUF 的默认值为8192:

==========================多线程============================================
服务器可以有三种方式来处理多客户端请求：
l 为每个客户分配一个工作线程。
2 创建一个线程池，由其中的工作线程来为客户服务。
3 利用JDK 的Java 类库中现成的线程池，由它的工作线程来为客户服务。

（1）为每个客户分配一个工作线程弊端：
①服务器不停地创建和销毁线程在时间和系统资源上的开销很大。
②当创建了大量的线程时，每个活动的线程都需要占用一定的内存，大约为1M左右，当线程数目过大时，可能会导致系统内存不足。

（2）线程池为线程生命周期开销问题和系统资源不足问题提供了解决方案。线程池中预先创建了
一些工作线程，它们不断从工作队列中取出任务，然后执行该任务。当工作线程执行完一个
任务时，就会继续执行工作队列中的下一个任务。线程池具有以下优点：
① 减少了创建和销毁线程的次数，每个工作线程都可以一直被重用，能执行多个任务。
② 可以根据系统的承载能力，方便地调整线程池中线程的数目，防止因为消耗过量系统资源

---------------------------JDK类库中的线程池------------------------------------------------
Executor 接口表示线程池，它的execute(Runnable task)方法用来执行Runnable 类型的任务
Executor 的子接口ExecutorService 中声明了管理线程池的一些方法，比如用于关闭线程池的
shutdown()方法等。Executors 类中包含一些静态方法，它们负责生成各种类型的线程池
ExecutorService 实例

public class Server{
	private int port = 7788;
	private ServerSocket server;
	private ExcuteService excute = null;
	public Server(){
		server = new ServerSocket(port);
		excute = Excutor.newCachedThreadPool();
		System.out.println("服务器启动");
	}
	
	public void service(){
		Socket socket = null;
		while(true){
			try{
				socket = server.accept();	
				excute.execute(new WorkThread(socket));
			}catch(Exception e){
				e.printStackTrace();
			}
		}
	}
	public static void main(String args[])throws IOException {
		new EchoServer().service();
	}

}
使用线程池的注意事项:
与所有多线程应用程序一样，用线程池构建的应用程序容易产生各种并发问题，如对共享资源的竞争和死锁。
此外，如果线程池本身的实现不健壮，或者没有合理地使用线程池，还容易导致与线程池有
关的死锁、系统资源不足和线程泄漏等问题。

------------------------死锁----------------------------
线程池导致的另外一种死锁：
在这种情形下，假
定线程池中的所有工作线程都在执行各自任务时被阻塞，它们都在等待某个任务A 的执行
结果。而任务A 依然在工作队列中，由于没有空闲线程，使得任务A 一直不能被执行。这
使得线程池中的所有工作线程都永远阻塞下去，死锁就这样产生了。
---------------------------------------------------------


系统资源不足：
如果线程池中的线程数目非常多，这些线程会消耗包括内存和其他系统资源在内的大量资
源，从而严重影响系统性能。

并发错误：
线程池的工作队列依靠wait()和notify()方法来使工作线程及时取得任务，但这两个方法都难
于使用。如果编码不正确，可能会丢失通知，导致工作线程一直保持空闲状态，无视工作队
列中需要处理的任务。因此使用这些方法时，必须格外小心，即便是专家也可能在这方面出
错。最好使用现有的、比较成熟的线程池。例如，直接使用java.util.concurrent 包中的线程
池类。

线程泄漏：
使用线程池的一个严重风险是线程泄漏。对于工作线程数目固定的线程池，如果工作线程在
执行任务时抛出 RuntimeException 或Error，并且这些异常或错误没有被捕获，那么这个工
作线程就会异常终止，使得线程池永久失去了一个工作线程。如果所有的工作线程都异常终
止，线程池就最终变为空，没有任何可用的工作线程来处理任务。
导致线程泄漏的另一种情形是，工作线程在执行一个任务时被阻塞，如等待用户的输入数据，
但是由于用户一直不输入数据（可能是因为用户走开了），导致这个工作线程一直被阻塞。
这样的工作线程名存实亡，它实际上不执行任何任务了。假如线程池中所有的工作线程都处
于这样的阻塞状态，那么线程池就无法处理新加入的任务了

